<html>

  <head>
    <style>
      .code
	    {
		  font-family: monospace;
		}
		
      .qa
	    {
		  font-weight: bold;
		}
		
	  #logo
	    {
		}
    </style>
  </head>

  <body>

	<h1> PT Designer library </h1> 

	<img id="logo" src="images/logo.png" alt="logo" width="100" />
	
	<p> This is an official web site of the PT Designer library, an open-source C/C++ procedural texture library. </p>
	
	<h2> FAQ </h2>

    <p>
	  <span class="qa" >Q</span>: What is PT Designer library? <br />
	  <span class="qa" >A</span>: PT Designer library is an open-source multiplatform library for 2D tiling procedural texture description and generation which
	     can be used with C or C++ language. It should be easy to use. The project was written as bachelor thesis in C and C++. As a part of the project there
		 is also a GUI tool, Texture Maker, that can be used to create a texture and save is as an XML file, which can be loaded and
		 worked with in the library. You can also use to the tool just to create an unique PNG textures. <br /> <br />
	
	  <span class="qa" >Q</span>: Can I use this for free? <br />
	  <span class="qa" >A</span>: Yes, you can use or modify the library and the tool for free, but please mention my name. The project is released under GPL license, see it for more details. <br /> <br />
		 
	  <span class="qa" >Q</span>: What is it useful for? <br />
	  <span class="qa" >A</span>: It is useful in multiple ways. Firstly, you can have unique high resolution procedural textures in your program if you use the library.
	     You don't have to store large PNG files along with your program, just keep small XML file that describes the texture and load them later
		 with the library and generate the texture when you need it, in any resolution. You can also easily modify the texture, even at run time,
		 if you want to make it look different. Or if you make any kind of abstract graphics, you can use the Texture Maker tool to quickly
		 generate interesting images that can serve as a base image for your art. <br /> <br />
		 
	  <span class="qa" >Q</span>: Who works on the library? Is it still being developed? <br />
	  <span class="qa" >A</span>: Only I work on the project (see above). Well, it's not being actively developed now, but if there are serious bugs, I can fix them. <br /> <br />
	  
	  <span class="qa" >Q</span>: I'd like to let you know about a bug or anything related to the library, how can I contact you? <br />
	  <span class="qa" >A</span>: See the contact above. <br /> <br />
	</p>

	<h2> Instalation </h2>


	<h2> Quick tutorial </h2>

	<p>
	  The library provides two interfaces: C and C++. The interface for C language is routine-based,
	  while the inteface for C++ offers higher abstraction and declarative-based texture description.
	  We'll look into both interfaces in the following paragraphs.
	</p>

	<p>
	  Our goal in both cases will be to create a texture by first creating three grayscale images, one
	  for each of the R, G and B channels, which will then be mixed together into one colorful image. The first
	  image is going to be bump noise, the second one is Voronoi diagram and the third one will be
	  generated from the Voronoi diagram by applying a circle transformation to it. Pictures below show
	  the texture graph description and the result image we're trying to achieve.
	</p>

	<img src="images/graph.svg" width="350" />
	
	<img src="images/texture.png" width="256" heigh="256" />
	
	<h3> C interface </h3>

	<p>
	  In order to use the C interface include the proctextures.h header file to your source code. It provides
	  algorithms for generation images such as Voronoi diagram and bump noise. These algorithm work with so
	  called color buffer, which is a data structure used for storing RGB images. It allows us to access the
	  image data it contains, modify it, or save the image to PNG file. Let's see how we can create the
	  texture described above:
	</p>

	<span class="code">
	  #include "proctextures.h" <br />
      <br />
	  int main() <br />
		{ <br />
	    &nbsp&nbsp	  t_color_buffer buffer1, buffer2, buffer3, buffer4; <br />
		  
		&nbsp&nbsp  color_buffer_init(&buffer1,512,512);       // initialise color buffer 1 with 512 x 512 resolution <br />
		&nbsp&nbsp  color_buffer_init(&buffer2,512,512);       // initialise color buffer 2 <br />
		  <br />
		&nbsp&nbsp  /* note we didn't initialise the buffers 3 and 4 as they'll be later initialised by <br />
		&nbsp&nbsp	 functions that require uninitialised buffers */ <br />
		  <br />
		&nbsp&nbsp  pt_bump_noise(&buffer1,0.7,0.01,1,0,0);               // generate bump noise into buffer 1 <br />
		&nbsp&nbsp  pt_voronoi_diagram_simple(0,20,&buffer2);             // generate Voronoi diagram into buffer 2 <br />
		&nbsp&nbsp  pt_transformation_circle(&buffer2,5,1,&buffer3);      // apply circle transformation to buffer 2 and store the result into buffer 3 (uninitialised) <br />
		&nbsp&nbsp  pt_mix_channels(&buffer1,&buffer2,&buffer3,&buffer4); // mix the channels into one image stored in buffer 4 (uninitialised) <br />
		  <br />
		&nbsp&nbsp  color_buffer_save_to_png(&buffer4,"texture.png");     // save the texture as PNG file <br />
		  <br />
		&nbsp&nbsp  // destroy the buffers and free their memory: <br />
		  <br />
		&nbsp&nbsp  color_buffer_destroy(&buffer1); <br />             
		&nbsp&nbsp  color_buffer_destroy(&buffer2); <br />            
		&nbsp&nbsp  color_buffer_destroy(&buffer3); <br />            
		&nbsp&nbsp  color_buffer_destroy(&buffer4); <br />           
		  <br />
		&nbsp&nbsp  return 0; <br />
		} <br />
	</span>

	<h3> C++ interface </h3>

	<p>
      C++ interface treats the texture at higher level than C. It uses so called blocks, which represent
	  one concrete operation, to compose a description graph similar to the one in the image above. Blocks
	  have inputs and one output, can have parameters and can be connected together to create the graph.
	  Besides the blocks, the graph holds global information, such as texture resolution or supersampling
	  level. Let's see how we can generate our texture with C++:
	</p>

	<span class="code">
	#include "ptdesigner.h" <br />
    <br />
	using namespace pt_design;  // important <br />
	<br />
	int main() <br />
	  { <br />
	&nbsp&nbsp	int ids[5];             // to store block IDs <br />
	&nbsp&nbsp	c_texture_graph graph;  // represents the texture <br />
		<br />
	&nbsp&nbsp	graph.set_resolution(512,512);   // set the resolution to 512 x 512 <br />
		<br />
	&nbsp&nbsp	// create and add blocks to the texture graph and store their IDs: <br />
		<br />
	&nbsp&nbsp	ids[0] = graph.add_block(new c_block_bump_noise()); <br />
	&nbsp&nbsp	ids[1] = graph.add_block(new c_block_voronoi_diagram()); <br />
	&nbsp&nbsp	ids[2] = graph.add_block(new c_block_circle_transform()); <br />
	&nbsp&nbsp	ids[3] = graph.add_block(new c_block_mix_channels()); <br />
	&nbsp&nbsp	ids[4] = graph.add_block(new c_block_file_save());  // this block saves the texture to PNG when executed <br />
		<br />
	&nbsp&nbsp	/* <br />
	&nbsp&nbsp	Default parameters for all blocks are set when they are created. Now we want to <br />
	&nbsp&nbsp	change the number of points of the Voronoi diagram to 20, which is done this way: <br />
	&nbsp&nbsp	*/ <br />
		<br />
	&nbsp&nbsp	graph.get_block_by_id(ids[1])->get_parameters()->set_int_value("number of points",20); <br />
		<br />
	&nbsp&nbsp	// make the connections between blocks: <br />
		<br />
	&nbsp&nbsp	graph.connect_by_id(ids[0],ids[3],0);  // connects bump noise to mix channels' slot 0 <br />
	&nbsp&nbsp	graph.connect_by_id(ids[1],ids[3],1); <br />
	&nbsp&nbsp	graph.connect_by_id(ids[2],ids[3],2); <br />
	&nbsp&nbsp	graph.connect_by_id(ids[1],ids[2],0); <br />
	&nbsp&nbsp	graph.connect_by_id(ids[3],ids[4],0); <br />
		<br />
	&nbsp&nbsp	graph.compute(false);  // compute the texture <br />
		<br />
	&nbsp&nbsp	// the blocks will be freed as the graph gets destroyed <br />
		<br />
	&nbsp&nbsp	return 0; <br />
	} <br />
	</span>

    <h2> Texturemaker </h2>
    
    <img src="gui.png" width="800"/>

    <ul>
      <li> 1: edit area - Here you can edit the texture graph blocks. It is possible to move (left click drag), connect (left click output/input), disconnect (right click) or delete blocks (delete key) here. </li>
      <li> 2: blocks -  </li>
      <li> 3: block preview - </li>
      <li> 4: global texture settings - </li>
      <li> 5: block information - </li>
      <li> 6: quick actions - These are frequently used actions including saving, block rotation, block deleting, running the computation or disconnecting mode. </li>
      <li> 7: menu items - Allows access to actions such as save, load the texture as XML, duplicate blocks or the program info. </li>
    </ul>

	<h2> Documentation </h2>
	
	Go to <a href="">documentation</a>.
	
	<h2> Example pixtures </h2>
	
	<h2> Downloads </h2>

	<ul>
	  <li> <a href=""> sources </a> </li>
	  <li> <a href=""> Windows binaries </a> </li>
	  <li> <a href=""> Linux binaries </a> </li>
	  <li> <a href=""> documentation </a> </li>
	</ul>

  </body>

</html>
